/*
 * Copyright (C) 1994-2019 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */
/**
 * @file	diswf.c
 *
 * @par Synopsis:
 * 	int diswf(int stream, float value)
 *
 *	Converts <value> into a Data-is-Strings floating point number and sends
 *	it to <stream>.  The converted number consists of two consecutive signed
 *	integers.  The first is the coefficient, at most <ndigs> long, with its
 *	implied decimal point at the low-order end.  The second is the exponent
 *	as a power of 10.
 *
 *	Returns DIS_SUCCESS if everything works well.  Returns an error code
 *	otherwise.  In case of an error, no characters are sent to <stream>.
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include <assert.h>
#include <stddef.h>
#include <stdio.h>

#include "dis.h"
#include "dis_.h"
#undef diswf

/**
 * @brief
 *	Converts <value> into a Data-is-Strings floating point number and sends
 *      it to <stream>.
 *
 * @param[in] stream	socket fd
 * @param[in] value 	value to be converted
 *
 * @return	int
 * @retval	DIS_SUCCESS	success
 * @retval	error code	error
 *
 */
int
diswf(int stream, double value)
{
	int		c;
	int		expon;
	unsigned	ndigs;
	int		negate;
	int		retval;
	unsigned	pow2;
	char		*cp;
	char		*ocp;
	double		dval;

	assert(stream >= 0);

	/* Make zero a special case.  If we don't it will blow exponent		*/
	/* calculation.								*/
	if (value == 0.0) {
		retval = dis_puts(stream, "+0+0", 4) != 4 ?
			DIS_PROTO : DIS_SUCCESS;
		return ((disw_commit(stream, retval == DIS_SUCCESS) < 0) ?
			DIS_NOCOMMIT : retval);
	}
	/* Extract the sign from the coefficient.				*/
	dval = (negate = value < 0.0) ? -value : value;
	/* Detect and complain about the infinite form.				*/
	if (dval > FLT_MAX)
		return (DIS_HUGEVAL);
	/* Compute the integer part of the log to the base 10 of dval.  As a	*/
	/* byproduct, reduce the range of dval to the half-open interval,       */
	/* [1, 10).								*/

	/* dis_dmx10 would be initialized by prior call to dis_init_tables */
	expon = 0;
	pow2 = dis_dmx10 + 1;
	if (dval < 1.0) {
		do {
			if (dval < dis_dn10[--pow2]) {
				dval *= dis_dp10[pow2];
				expon += 1 << pow2;
			}
		} while (pow2);
		dval *= 10.0;
		expon = -expon - 1;
	} else {
		do {
			if (dval >= dis_dp10[--pow2]) {
				dval *= dis_dn10[pow2];
				expon += 1 << pow2;
			}
		} while (pow2);
	}
	/* Round the value to the last digit					*/
	dval += 5.0 * disp10d_(-FLT_DIG);
	if (dval >= 10.0) {
		expon++;
		dval *= 0.1;
	}
	/* Starting in the middle of the buffer, convert coefficient digits,	*/
	/* most significant first.						*/
	ocp = cp = &dis_buffer[DIS_BUFSIZ - FLT_DIG];
	ndigs = FLT_DIG;
	do {
		c = dval;
		dval = (dval - c) * 10.0;
		*ocp++ = c + '0';
	} while (--ndigs);
	/* Eliminate trailing zeros.						*/
	while (*--ocp == '0');
	/* The decimal point is at the low order end of the coefficient		*/
	/* integer, so adjust the exponent for the number of digits in the	*/
	/* coefficient.								*/
	ndigs = ++ocp - cp;
	expon -= ndigs - 1;
	/* Put the coefficient sign into the buffer, left of the coefficient.	*/
	*--cp = negate ? '-' : '+';
	/* Insert the necessary number of counts on the left.			*/
	while (ndigs > 1)
		cp = discui_(cp, ndigs, &ndigs);
	/* The complete coefficient integer is done.  Put it out.		*/
	retval = dis_puts(stream, cp, (size_t)(ocp - cp)) < 0 ?
		DIS_PROTO : DIS_SUCCESS;
	/* If that worked, follow with the exponent, commit, and return.	*/
	if (retval == DIS_SUCCESS)
		return (diswsi(stream, expon));
	/* If coefficient didn't work, negative commit and return the error.	*/
	return ((disw_commit(stream, FALSE) < 0)  ? DIS_NOCOMMIT : retval);
}
