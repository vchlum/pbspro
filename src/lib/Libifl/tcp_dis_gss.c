/*
 * Copyright (C) 1994-2019 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>

#include "pbs_ifl.h"
#include "net_connect.h"
#include "attribute.h"
#include "dis.h"
#include "pbs_gss.h"
#include "batch_request.h"

enum TCP_GSS_MSG_TYPES {
        TCP_GSS_CTX = 1, /* starts from 1, zero means EOF */
        TCP_GSS_WRAP,
        TCP_GSS_LAST_MSG
};

/**
 * @brief
 *	Display messages on stderr
 *
 * @param[in] func_name - function name that invokes the error
 * @param[in] msg - error message
 */
void
tcp_gss_display(const char *func_name, const char* msg)
{
	fprintf(stderr, "%s : %s\n", func_name, msg);
}

/**
 * @brief
 *	Display GSS-API messages associated with maj_stat or min_stat to the
 *	stderr
 *
 * @param[in] m - error message followed by GSS maj or min message
 * @param[in] code - gss error code
 * @param[in] type - type of gss error code
 */
static void
display_status_1(const char *m, OM_uint32 code, int type)
{
	OM_uint32 min_stat;
	gss_buffer_desc msg;
	OM_uint32 msg_ctx;
	msg_ctx = 0;

	do {
		gss_display_status(&min_stat, code, type, GSS_C_NULL_OID, &msg_ctx, &msg);
		fprintf(stderr, "%s : %.*s\n", m, (int)msg.length, (char *)msg.value);
		(void) gss_release_buffer(&min_stat, &msg);
	} while (msg_ctx != 0);
  }

/**
 * @brief
 *	The GSS-API messages associated with maj_stat and min_stat are
 *	displayed on stderr, each preceeded by "GSS-API error <msg>: " and
 *	followed by a newline.
 *
 * @param[in] msg - a error string to be displayed with the message
 * @param[in] maj_stat - the GSS-API major status code
 * @param[in] min_stat - the GSS-API minor status code
 */
void
tcp_gss_display_status(const char *msg, OM_uint32 maj_stat, OM_uint32 min_stat)
{
	display_status_1(msg, maj_stat, GSS_C_GSS_CODE);
	display_status_1(msg, min_stat, GSS_C_MECH_CODE);
}

/**
 * @brief
 * 	-gss_parse_token - receive gss token
 *
 * @param[in] fd - file descriptor
 * @param[out] type - token type - context or wrapped msg
 * @param[out] data_out - token string data
 * @param[out] len_out - length of data
 *
 * @return	int
 * @retval	PBS_GSS_OK 	on success
 * @retval	!= PBS_GSS_OK	on error
 *
 */
int
gss_parse_token(int fd, enum TCP_GSS_MSG_TYPES *type, char **data_out, int *len_out)
{
	int i = 0;
	unsigned int data_len;
	char *data;

	i = dis_getc(fd);
	if (i <= 0) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_RECVTOKEN;
	}
	*type = (enum TCP_GSS_MSG_TYPES)i;
	if (*type > TCP_GSS_LAST_MSG || *type < TCP_GSS_CTX) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_RECVTOKEN;
	}

	data = malloc(sizeof(int));
	if (data == NULL) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_INTERNAL;
	}

	i = dis_gets(fd, data, sizeof(int));
	if (i <= 0) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_RECVTOKEN;
	}
	if (i < sizeof(int)) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_RECVTOKEN;
	}

	data_len = ntohl(*((int *) data));
	free(data);
	data = malloc(data_len);
	if (data == NULL) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_INTERNAL;
	}
	i = dis_gets(fd, data, data_len);
	if (i <= 0) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_RECVTOKEN;
	}
	if (i < data_len) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_RECVTOKEN;
	}
	disw_commit(fd, 1);
	*data_out = data;
	*len_out = data_len;
	return PBS_GSS_OK;
}

/**
 * @brief
 * 	-gss_create_token - assemble gss token and writes the token into
 *	writebuf for wflush
 *
 * @param[in] fd - file descriptor
 * @param[in] type - token type - context or wrapped msg
 * @param[in] data - token string data
 * @param[in] len - length of data
 *
 * @return	int
 * @retval	PBS_GSS_OK 	on success
 * @retval	!= PBS_GSS_OK	on error
 *
 */
int
gss_create_token(int fd, enum TCP_GSS_MSG_TYPES type, char *data, int len)
{
	int retval = DIS_SUCCESS;
	int ntotlen;
	char bufflen[sizeof(int)];

	ntotlen = htonl(len);
	memcpy(bufflen, &ntotlen, sizeof(int));

	dis_reset_buf(fd, DIS_WRITE_BUF);
	retval = dis_puts(fd, (char*)&type, 1) != 1 ? DIS_PROTO : DIS_SUCCESS;
	if (retval == DIS_SUCCESS) {
		retval = dis_puts(fd, bufflen, sizeof(int)) != sizeof(int) ? DIS_PROTO : DIS_SUCCESS;
	}
	if (retval == DIS_SUCCESS) {
		retval = dis_puts(fd, data, len) != len ? DIS_PROTO : DIS_SUCCESS;
	}

	disw_commit(fd, retval == DIS_SUCCESS);
	if (retval != DIS_SUCCESS)
		return PBS_GSS_ERR_SENDTOKEN;

	return PBS_GSS_OK;
}

/**
 * @brief
 * 	dis_gss_encrypt - encrypt given data and assemble gss token and writes the token into
 *	dis write buffer for flush
 *
 * @param[in] fd - file descriptor
 * @param[in] data - string data
 * @param[in] len - length of data
 *
 * @return	int
 * @retval	0	on success
 * @retval	-1	on error
 *
 */
int
dis_gss_encrypt(int fd, void *data_in, int len_in)
{
	pbs_gss_extra_t *gss_extra = NULL;
	char *data_out;
	int len_out;

	gss_extra = (pbs_gss_extra_t *)transport_chan_get_extra(fd);
	if (gss_extra == NULL)
		return -1;

	if (!data_in)
		return DIS_PROTO;

	if (len_in == 0)
		return 0;

	if (gss_extra->ready) {
		if (pbs_gss_wrap(gss_extra, data_in, len_in, &data_out, &len_out) != PBS_GSS_OK)
			return -1;
		if (gss_create_token(fd, TCP_GSS_WRAP, data_out, len_out) != PBS_GSS_OK)
			return -1;
		free(data_out);
	}

	return 0;
}

/**
 * @brief
 * 	dis_gss_decrypt - read gss token from dis read buffer and decrypt it
 * 	and put decrypted text back in dis read buffer
 *
 * @param[in] fd - file descriptor
 *
 * @return	int
 * @retval	0	on success
 * @retval	-1	on error
 *
 */
int
dis_gss_decrypt(int fd)
{
	pbs_gss_extra_t *gss_extra = NULL;

	gss_extra = (pbs_gss_extra_t *)transport_chan_get_extra(fd);
	if (gss_extra == NULL)
		return -1;

	if (gss_extra->ready) {
		char *data_in = NULL;
		int len_in = 0;
		char *data_out = NULL;
		int len_out = 0;
		enum TCP_GSS_MSG_TYPES type;
		int i;

		i = gss_parse_token(fd, &type, &data_in, &len_in);
		if (i != PBS_GSS_OK) {
			return i;
		}
		if (type != TCP_GSS_WRAP) {
			return -1;
		}
		if (pbs_gss_unwrap(gss_extra, data_in, len_in, &data_out, &len_out) != PBS_GSS_OK) {
			free(data_out);
			free(data_in);
			return -1;
		}
		dis_fill_readbuf(fd, data_out, len_out);
		free(data_in);
		free(data_out);
	}
	return 0;
}

/**
 * @brief
 * 	-__tcp_gss_process - this function handles data before process_request()
 *	if the data are GSS handshake related then handshake is done
 *	if the data are wrapped then unwrapping is done and true is returned
 *	if gss is not used (yet) then true is returned
 *
 *
 * @param[in] sfds - socket descriptor
 * @param[in] hostname - server hostname
 * @param[out] ebuf - error buffer
 * @param[in] ebufsz - size of error buffer
 *
 * @return	int
 * @retval	>0	data ready
 * @retval	0	no data ready
 * @retval	-1	error
 * @retval	-2	on EOF
 *
 */
int
__tcp_gss_process(int sfds, char *hostname, char *ebuf, int ebufsz)
{
	pbs_gss_extra_t *gss_extra = NULL;
	char *data = NULL;
	int data_len = 0;
	char *data_out = NULL;
	int len_out = 0;
	enum TCP_GSS_MSG_TYPES type;
	int i;

	DIS_tcp_funcs();

	if ((gss_extra = (pbs_gss_extra_t *)transport_chan_get_extra(sfds)) == NULL) {
		gss_extra = pbs_gss_alloc_gss_extra();
		if (gss_extra == NULL) {
			snprintf(ebuf, ebufsz, "gss_extra allocation failed");
			pbs_errno = PBSE_SYSTEM;
			return PBS_GSS_ERR_INTERNAL;
		}
		transport_chan_set_extra(sfds, gss_extra);
	}

	gss_extra->role = PBS_GSS_SERVER;

	if (gss_extra->hostname == NULL) {
		gss_extra->hostname = strdup(hostname);
		if (gss_extra->hostname == NULL) {
			snprintf(ebuf, ebufsz, "malloc failure");
			return -1;
		}
	}

	if (gss_extra->establishing == 0 && gss_extra->ready == 0)
		return 1; /* no gss token (yet) -> cleartext is ready */

	if (gss_extra->gssctx_established == 1 && gss_extra->ready == 1)
		return 1;

	i = gss_parse_token(sfds, &type, &data, &data_len);
	if (i != PBS_GSS_OK)
		return -1;
	if (pbs_gss_establish_context(gss_extra, gss_extra->hostname, data, data_len, &data_out, &len_out) != PBS_GSS_OK) {
		snprintf(ebuf, ebufsz, "Failed to establish GSS context");
		return -1;
	}

	if (len_out > 0) {
		if (gss_create_token(sfds, TCP_GSS_CTX, data_out, len_out) != PBS_GSS_OK) {
			snprintf(ebuf, ebufsz, "Failed to send GSS context token");
			free(data_out);
			free(data);
			data_len = 0;
			len_out = 0;
			return -1;
		}
		if (dis_flush(sfds) < 0) {
			return PBS_GSS_ERR_SENDTOKEN;
		}
	}

	free(data_out);
	free(data);
	data_len = 0;
	len_out = 0;

	if (gss_extra->gssctx_established) {
		gss_extra->ready = 1;
		transport_chan_set_before_send(sfds, (void *)&dis_gss_encrypt);
		transport_chan_set_after_recv(sfds, (void *)&dis_gss_decrypt);
		transport_chan_set_extra(sfds, gss_extra);
		return 0;
	}
	return -1;
}


/**
 * @brief
 * 	-tcp_gss_send_auth - encodes and sends auth batch request,
 *	which initiates the gss handshake on server
 *
 * @param[in] sock - socket descriptor
 *
 * @return	int
 * @retval	PBS_GSS_OK on success
 * @retval	!= PBS_GSS_OK on error
 */
int
tcp_gss_send_auth(int sock)
{
	struct batch_reply *reply;
	int rc;

	DIS_tcp_funcs();

	if (encode_DIS_ReqHdr(sock, PBS_BATCH_AuthExternal, pbs_current_user) ||
		diswuc(sock, AUTH_GSS) || /* authentication_type */
		diswsi(sock, 0) || /* credentials length not used */
		encode_DIS_ReqExtend(sock, NULL)) {

		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_INTERNAL;
	}

	if (dis_flush(sock)) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_INTERNAL;
	}

	reply = PBSD_rdrpy_sock(sock, &rc);

	if (reply == NULL) {
		pbs_errno = PBSE_BADCRED;
		return PBS_GSS_ERR_INTERNAL;
	}

	if ((reply->brp_code != 0)) {
		pbs_errno = PBSE_BADCRED;
		PBSD_FreeReply(reply);
		return PBS_GSS_ERR_INTERNAL;
	}

	PBSD_FreeReply(reply);

	return PBS_GSS_OK;
}

/**
 * @brief
 * 	-tcp_gss_client_authenticate - sends the auth batch request and
 *	initiates and performs the gss handshake on client
 *
 * @param[in] sock - socket descriptor
 * @param[in] hostname - server hostname
 * @param[out] ebuf - error buffer
 * @param[in] ebufsz - size of error buffer
 *
 * @return	int
 * @retval	PBS_GSS_OK on success
 * @retval	!= PBS_GSS_OK on error
 */
int
tcp_gss_client_authenticate(int sock, char *hostname, char *ebuf, int ebufsz)
{
	pbs_gss_extra_t *gss_extra = NULL;
	char *data_in = NULL;
	int len_in = 0;
	char *data_out = NULL;
	int len_out = 0;
	enum TCP_GSS_MSG_TYPES type;
	int i;

	if ((gss_extra = (pbs_gss_extra_t *)transport_chan_get_extra(sock)) == NULL) {
		gss_extra = pbs_gss_alloc_gss_extra();
		if (gss_extra == NULL) {
			snprintf(ebuf, ebufsz, "gss_extra allocation failed");
			pbs_errno = PBSE_SYSTEM;
			return PBS_GSS_ERR_INTERNAL;
		}
		transport_chan_set_extra(sock, gss_extra);
	}

	gss_extra->role = PBS_GSS_CLIENT;

	if (gss_extra->hostname == NULL) {
		gss_extra->hostname = strdup(hostname);
		if (gss_extra->hostname == NULL) {
			snprintf(ebuf, ebufsz, "malloc failure");
			pbs_errno = PBSE_SYSTEM;
			return PBS_GSS_ERR_INTERNAL;
		}
	}

	if (tcp_gss_send_auth(sock) != PBS_GSS_OK) {
		snprintf(ebuf, ebufsz, "authentication failed");
		return PBS_GSS_ERR_INTERNAL;
	}

	pbs_gss_set_log_handlers(tcp_gss_display_status, tcp_gss_display, NULL);

	do {
		if (pbs_gss_establish_context(gss_extra, gss_extra->hostname, data_in, len_in, &data_out, &len_out) != PBS_GSS_OK) {
			snprintf(ebuf, ebufsz, "Failed to establish GSS context");
			pbs_errno = PBSE_SYSTEM;
			return PBS_GSS_ERR_CONTEXT_ESTABLISH;
		}

		if (len_in) {
			free(data_in);
			data_in = NULL;
			len_in = 0;
		}

		if (len_out) {
			if (gss_create_token(sock, TCP_GSS_CTX, data_out, len_out) != PBS_GSS_OK) {
				snprintf(ebuf, ebufsz, "Failed to send GSS context token");
				pbs_errno = PBSE_SYSTEM;
				free(data_out);
				data_out = NULL;
				len_out = 0;
				return PBS_GSS_ERR_SENDTOKEN;
			}
			if (dis_flush(sock) < 0) {
				return PBS_GSS_ERR_SENDTOKEN;
			}
			free(data_out);
			data_out = NULL;
			len_out = 0;
		}

		if (gss_extra->gssctx_established == 0) {
			/* recieve ctx token */
			i = gss_parse_token(sock, &type, &data_in, &len_in);
			if (i != PBS_GSS_OK) {
				return i;
			}
			if (type != TCP_GSS_CTX) {
				snprintf(ebuf, ebufsz, "incorrect GSS token type");
				pbs_errno = PBSE_SYSTEM;
				return PBS_GSS_ERR_RECVTOKEN;
			}
		}

		if (gss_extra->gssctx_established) {
			gss_extra->ready = 1;
			transport_chan_set_before_send(sock, (void *)&dis_gss_encrypt);
			transport_chan_set_after_recv(sock, (void *)&dis_gss_decrypt);
		}

	} while (gss_extra->ready == 0);

	transport_chan_set_extra(sock, gss_extra);
	return PBS_GSS_OK;
}
#endif
